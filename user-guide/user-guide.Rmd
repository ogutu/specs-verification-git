% The **SpecsVerification** package user guide
% Stefan Siegert
% Version: January 2014


```{r, echo=FALSE}
opts_chunk$set(tidy=FALSE, dev="pdf", warning=FALSE, comment="R output >> ", results='hold')
```


# Install and load

Specify the directory of the package source (i.e. the directory that contains the subdirectories `R`, `man` and the files `DESCRIPTION` and `NAMESPACE` etc) and the directory where the package should be installed. For example:

```{r}
pkgdir <- "/home/stefan/folders/specs/r-package/specs-verification-git"
destdir <- "/tmp"
```

Then install and load the package as follows:

```{r}
install.packages(pkgdir, repo=NULL, lib=destdir, type="source")
library("SpecsVerification", lib.loc=destdir)
```


# Load some example data

We will use seasonal ensemble forecast of surface temperature averaged over the `Atl3` region between 1993 and 2009, initialized twice a year (1 May and 1 November) and run 1 up to 4 months into the future.
"Observations" are generated from the `ERAint` data set. 
Ensemble forecasts are generated by `ECMWF System4` (15 members) and an anomaly initialized ensemble generated at IC3.
The data can be downloaded from the SPECS wiki: [Atl3.ERAint.Rdata](http://www.specs-fp7.eu/wiki/images/a/a8/Atl3.ERAint.Rdata)



```{r}
file <- "Atl3.ERAint.Rdata"
if (!file.exists(file)) {
  download.file(url="http://www.specs-fp7.eu/wiki/images/a/a8/Atl3.ERAint.Rdata", 
                destfile=file)
}
load(file)

# the dimensions of obs are 1:initdate, 2:leadtime
dimnames(obs) 

# the dimensions of ens are 1:initdate, 2:leadtime, 3:ensemble, 4:member
dimnames(ens) 
```

```{r plot-ens-ver, fig.width=6, fig.height=4, fig.cap="Time series of the ensemble data and observations"}
t <- paste(seq.Date(from=as.Date("1993-05-01"), 
           to=as.Date("2009-05-01"), by="1 year"))
ecmwf <- ens[t,"1","ecmwf",]
l00w <- ens[t,"1","l00w",1:5]
ver <- obs[t,"1"]
plot(NULL, xlim=c(1, length(ver)), ylim=range(c(ver,l00w,ecmwf)), 
     xlab="time", ylab="Atl3 temp. [C]")
points(ver, pch=15, cex=1.5, col=gray(.5))
for (i in 1:nrow(ecmwf)) points(rep(i-.2,15), ecmwf[i,], pch=15, cex=0.5)
for (i in 1:nrow(ecmwf)) lines(rep(i-.2,2), range(ecmwf[i,]))
for (i in 1:nrow(l00w)) points(rep(i+.2,5), l00w[i,], pch=16, cex=0.5)
for (i in 1:nrow(l00w)) lines(rep(i+.2,2), range(l00w[i,]))
legend(x="bottomright", ncol=3, legend=c("l00w","ecmwf","obs"), 
       lty=c(1,1,NA), pch=c(16,15,15), pt.cex=c(0.7,0.7,1.5), 
       col=c("black","black",gray(.5)))
```

# Fair Brier Score analysis

The function `FairBrier` returns individual values of fair Brier scores of ensembles and their verifications. The argument `tau` is the threshold to whose exceedance defines the binary event:

```{r plot-fbr, fig.width=4, fig.height=3, fig.cap="Plot of fair Brier Scores of ECMWF (gray) and l00w (black)."}
fbr.ecmwf <- FairBrier(ens=ecmwf, obs=ver, tau=28.5)
fbr.l00w <- FairBrier(ens=l00w, obs=ver, tau=28.5)
plot(fbr.ecmwf, type="b", pch=15, col=gray(.5))
lines(fbr.l00w, type="b", pch=16, col="black")
print(c(mean(fbr.ecmwf), mean(fbr.l00w)))
```

The function `AnalyzeFairBrier` returns the mean fair Brier score difference and optional estimated quantiles of the sampling distribution of the mean difference:

```{r}
FairBrierDiff(ens=l00w, ens.ref=ecmwf, obs=ver, 
                 tau=28.5, probs=c(0.05, 0.95))
```


# Fair CRPS analysis

The fair continuously ranked probability score for ensemble forecasts has similar routines as the fair Brier score:

```{r plot-fcrps, fig.width=4, fig.height=3, fig.cap="Plot of fair CRPS of ECMWF (gray) and l00w (black)."}
fcrps.ecmwf <- FairCrps(ens=ecmwf, obs=ver)
fcrps.l00w <- FairCrps(ens=l00w, obs=ver)
plot(fcrps.ecmwf, type="b", pch=15, col=gray(.5))
lines(fcrps.l00w, type="b", pch=16, col="black")
print(c(mean(fcrps.ecmwf), mean(fcrps.l00w)))
print(FairCrpsDiff(ens=l00w, ens.ref=ecmwf, obs=ver, probs=c(0.05, 0.95)))
```


# Rank histogram analysis


The ECMWF ensemble and the observations are transformed to anomalies by centering them around zero. Then the rank histogram is drawn in the "raw" version and on probability paper:

```{r rankhist, fig.width=4, fig.height=4}
ecmwf <- ens[,1,"ecmwf",]
ecmwf <- ecmwf - mean(ecmwf)
ver <- obs[,1]
ver <- ver - mean(ver)
rh <- Rankhist(ens=ecmwf, obs=ver)
PlotRankhist(rh, mode="raw")
PlotRankhist(rh, mode="prob.paper")
```


# Reliability diagram analysis

The experimental l00w ensemble and the observations are transformed to anomalies. The event of interest is the exceedance of a value of 1 and probabilities are generated for this event by counting ensemble members:



```{r reldiag, fig.width=4, fig.height=4}
l00w <- ens[,4,"l00w",]
l00w <- l00w - mean(l00w, na.rm=TRUE)
p <- rowMeans(l00w > 1, na.rm=TRUE)
ver <- obs[,4]
ver <- ver - mean(ver)
y <- 1 * (ver > 1)
rd <- ReliabilityDiagram(probs=p, obs=y, bins=c(0,1/3,2/3,1), 
                         plot=TRUE, nboot=500, mc.cores=8)
```

The object `rd` contains all the numerical information to create the diagram from scratch:

```{r}
print(rd)
```


# Brier Score decomposition

The decomposition of the Brier score for probability forecasts quanitifies the violation of realibility and the resolution of the forecast, and the uncertainty of the observations:

```{r}
BrierScoreDecomposition(p,y,calibration=list(method="bin", bins=c(0,1/3,2/3,1)))
```

A new (experimental) method to estimate the calibration function by a logistic regression model is implemented:

```{r}
BrierScoreDecomposition(p,y,calibration=list(method="logistic"))
```

# Ensemble Dressing

Ensemble dressing is a method to transform a discrete ensemble into a continuous probability distribution function by dressing each ensemble member with a kernel function (for example a Gaussian distribution function) and averaging over the individual kernels. 

A few ensemble dressing methods have been implemented. The `DressEnsemble` method transforms a $N\times K$ matrix of $K$ ensemble members into a `dressed.ensemble` object. The function `PlotDressedEns` is useful for examining the result.

```{r plot-dressing, fig.width=6, fig.height=4, fig.cap="Plot of the dressed ECMWF ensemble"}
t <- paste(seq.Date(from=as.Date("1993-05-01"), 
                    to=as.Date("2009-05-01"), by="1 year"))
ecmwf <- ens[t,4,'ecmwf',]
ver <- obs[t,4]
d.ens <- DressEnsemble(ecmwf)
PlotDressedEns(d.ens, plot.ens=TRUE, obs=ver)
```

By default, the function `DressEnsemble` uses Gaussian kernels, centered on the ensemble members, and the kernel width is calculated by Silverman's rule of thumb ($\sigma_{ker} = \left(\frac4{3K}\right)^{1/5} \sigma_{ens}$).

A more clever version of ensemble dressing is Affine Kernel Dressing (AKD), where the centers of the kernels are transformations of the ensemble members and the kernel variance is a function of the ensemble variance:

$$ p(x|e) = \frac{1}{K} \sum_{k=1}^K \frac{1}{s_k(e)} \varphi\left(\frac{x-m_k(e)}{s_k(e)}\right)$$

where

$$m_k(e) = r_1 + r_2 \bar{e} + a e_k$$
$$s_k^2(e) = \left(\frac{4}{3K}\right)^{2/5}\left(s_1 + s_2 a^2 \sigma_{e}^2\right)$$

 The parameters of the two transformations can be specified by the user or can be estimated by minimum CRPS estimation.

A few examples illustrate the capabilities of the method. The following behaves like the standard Silverman method, but the ensemble means are shifted by three degrees:

```{r plot-dressing-shift, fig.width=6, fig.height=3.5, fig.cap="Shifted ensemble"}
shift <- 3
d.ens <- DressEnsemble(ecmwf, dressing.method="akd", 
                       parameters=list(r1=shift, r2=0, a=1, s1=0, s2=1))
PlotDressedEns(d.ens, plot.ens=TRUE, obs=ver)
```

The following uses very narrow kernels:

```{r plot-dressing-underdisp, fig.width=6, fig.height=3.5, fig.cap="Narrow kernels"}
d.ens <- DressEnsemble(ecmwf, dressing.method="akd", 
                       parameters=list(r1=0, r2=0, a=1, s1=0, s2=0.01))
PlotDressedEns(d.ens, plot.ens=TRUE, obs=ver)
```

The AKD parameters can be calculated by minimum CRPS estimation, for which a set of observations must be provided:


```{r plot-dressing-fit, fig.width=6, fig.height=3.5, fig.cap="Minimum CRPS parameters"}
d.ens <- DressEnsemble(ecmwf, dressing.method="akd.fit", 
                       parameters=list(obs=ver))
PlotDressedEns(d.ens, plot.ens=TRUE, obs=ver)
```

The function `FitAkdParameters` returns the actual parameter values:

```{r}
FitAkdParameters(ecmwf, ver)
```

which basically shows that the influence of the individual ensemble members is small ($a\approx 0$) and that the influence of the ensemble mean and the ensemble standard deviation is small ($r_2 \ll r_1$ and $s_2 a^2 \ll s1$).

The functions `DressCrps` and `DressIgn` calculate the continuously ranked probability score and Ignorance score of a collection of dressed ensembles and their verifications:

```{r}
DressCrps(d.ens, obs)
DressIgn(d.ens, obs)
```

The CRPS and Ignorance differences between two dressed ensemble forecasts can be analyzed:

```{r}
l00w <- ens[t,4,'l00w',1:5]
d.ens.new <- DressEnsemble(l00w, dressing.method="akd.fit", 
                           parameters=list(obs=ver))
DressCrpsDiff(d.ens.new, d.ens, ver, probs=c(0.05, 0.95))
DressIgnDiff(d.ens.new, d.ens, ver, probs=c(0.05, 0.95))
```

The average score differences are slightly larger than zero but the sampling fluctuation of the score is probably too large to make a definite statement about which ensemble is better. It is important to realize that the above analysis is not an evaluation of the ensemble forecasts themselves, but an evaluation of the ensemble forecast *and* the statistical machinery that transformed the ensemble into a smooth pdf.










